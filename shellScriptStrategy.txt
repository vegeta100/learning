1.4 shell进行数学运算

let，其参数是算术运算表达式，常量就不是字符串了，而是整数
算术表达式中$a是a的值，并不是变量a。把一个常量放赋值表达式左边是错的。

同样地，$[]将字符串变成了算术运算表达式。
也就是说，[]才能装表达式，和if[]是一个道理。

$() ``
这两个都是包含命令的，
$[] $(())
这两个是包含算术运算的，但未必是算术表达式，目前看到的，[]包住的只是等式的右边。
从上到下，等级高了，也从命令变成算术表达式了。

以上是整数相关的运算，所以，shell脚本里只能用整数运算？
脚本并不是需求严格的应用程序，整数就足够了。需要小数的时候，shell脚本里有另外的工具。
毕竟，文件描述符是整数，很少有什么东西是小数的，



1.5 文件描述符和重定向
标准错误似乎是标准输出的一部分

$？是系统变量？它是命令执行的退出状态的，
echo $?会打印上一条命令执行的退出状态，那还蛮方便的

说一下标准输入，stdin
echo a1这些是由标准输入接收的
键盘输入即是标准输入，所以，说echo a1是由标准输入接收的，理解起来没错的
键盘输入属于标准输入，不完全等同于标准输入，这样的说法才是对的
不然，管道的左边是输入这个说法就说不通了

/dev/null
为什么是空设备来表示空文件呢？
1˃ 标准输出重定向
2˃ 标准错误重定向
一个命令执行正常，会定向到标准输出；而执行错误，则定向到标准错误。
可以给这两个重定向个文件，让它的标准输出和标准错误分类明确。

&> 这个符号的含义是，不管标准错误还是标准输出，都定向到同一个文件。

tee,三通，可以理解为three
