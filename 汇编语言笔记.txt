第2章
2.4
地址总线上的20位信息，是现在寄存器里存放的，而寄存器只有16位，所以，需要转换一下

2.5
字节是8个位，字长得看cpu的结构。16位机的字长为16,8位机的字长为8。字长，是cpu中寄存器的位数
寄存器和运算器之间的通路？通路是指什么？
cpu暂时存储地址我懂，传输，是指通过16位的数据总线传输，也明白。但处理是指什么啊？难道和运算一个意思？
cpu暂存存放地址，当然是放在寄存器里面了，然后再给到地址总线那里

2.6

2.8
段地址是起始，
物理地址：区别于段地址和偏移地址，物理地址是切切实实的地址，没有水分的。所以才叫物理。

2.11
jmp ax 等价于 mv ip,ax
也就是说，我们可以先改ax bx这些寄存器，再更改ip里面的内容
问题2.3
mov ax,6622H
jmp 1000:3
mov ax,0000
mov bx,ax
jmp bx
mov ax,0123H
mov ax,0000
mov bx,ax
jmp bx
mov ax,0123H
mov ax,0000
...重复循环了

实验1
debug的最右边部分，每一个字母对应中间的一个字节，那只能是ASCII码，毕竟一个字节范围只有0-255
ASCII码是7位的，247会转成119
或者247-128,就会得到需要的结果

a assemble
有一句话叫输入到程序，输出到硬盘。主语是 程序，所以读取东西的时候，就该说输入。现在汇编在操作内存，但主语是内存，所以得用输入
还有另一种说法，输入是参与运算的，输出是结果。
有时候说输出到屏幕，因为到了屏幕，已经是最终结果了，所以嘛，说输出是没问题的

第3章
3.1
字，也就是一个数据，比如20000，它用到了2个字节。要一个完整的寄存器（包括高低位）才能存储。
16位结构，16根线。内部总线传数据也是16根，虽说地址线是20根，但是在抵达地址线之前，肯定要先传个地址给到这里，但16位结构就是16根线的，所以地址需要经过运算才行。
3.2
DS是访问数据的段地址，那cs是要访问指令的段地址？
cs：代码段寄存器，是 code segment 的缩写；跟指令有关的，指令也就是汇编的代码
cs+ip所指的地方，就是当前要执行的指令

ds：数据段寄存器，是 data segment 的缩写；
ss：堆栈段寄存器， 是 stack segment 的缩写；
es：附加段寄存器，是 extra segment 的缩写；
3.4
ds和cs一样有ip吗？还是？
和ds相关的[]是干嘛的

问题3.5:
mov ax,123bH
mov ds,ax
-------mov ax,0--------这条我没加
add ax,[0]
add ax,[2]
add ax,[4]

检测点3.1
2).
mov ax,6622	ax:6622 
jmp 0ff0:0100	
mov ax，2000	ax:2000
mov ds,ax	ds:2000
mov ax,[8]	ax:c389
mov ax,[2]	ax:ea66

3.8
栈的空间是ss地址~栈没数据时的指向sp作为空间范围
3.9
内存单元在《汇编语言》这本书里，指的就是DS寄存器的偏移的内存单元。也确实是在和内存单元打交道，不同于寄存器打交道。
内存单元并不想ip那样，它是没有专门的寄存器来存放内存里的偏移位置的。
问题3.7:
初始的ss sp即约束了栈的大小

问题3.8:
mov cx,1000
mov ss,cx
mov cx,0010
mov sp,cx
mov ax,001ah
mov bx,001bh
push ax
push bx
mov ax,0
mov bx,0
pop bx
pop ax

问题3.9:
mov cx,1000H
mov ss,cx
mov sp,0010H这一点还是搞错了，写成000fH了
mov ax,001aH
mov bx,001bH
push ax
push bx
pop ax
pop bx

问题3.10:
mov ax,1000H
mov ss,ax
mov sp,0002H

3.10
一个栈段最大为64KB，是因为SP是16位的，最多是64KB空间。
8086低地址在前，高地址在后。字地址是低地址，但拼成一个字，是先从高地址拿东西出来的。
既然字地址是低地址，那空的栈，sp就是栈的底部界限+1了。低地址+2嘛。

段的综述；
代码也就是汇编指令
一段内存，即可以是代码段、数据段和栈段，但最好单一一点，太复杂了编写程序会很晕的

检测点3.2
pop之后，原来的栈段内，数据发生怎么样的变化了，清零了？还是不变？

实验2
执行与运行，运行程序是内存，执行包括了计算，需要cpu。

SS是堆栈寄存器
SA是堆栈地址

中断机制，
t命令执行一条指令停了下来，是因为用了中断

最后的实验，ss:sp这段内存空间有变化，是因为什么呢？


第4章
4.1
根据可执行程序的描述信息，将其加载到内存中
这里说明里程序的运行，内存就像一条船，必须把程序承载到上面才有可能工作。但内存主要负责的是承载，工作的话，即执行程序的话，需要cpu。

4.2
程序返回：我的理解是，返回到上一个程序，即使目标程序运行的程序。

我明白为什么用segment ends了
因为汇编程序里可能有好几个segment，不加ends的话，是不会因为执行到结束就不执行的。我原先假想的执行到没有了，就结束，是不存在的，除非只有一个segment。

连接：因为可能要合并其他的库中的子程序，所以叫连接是很合理的

列表文件什么的，暂时可以不用管吧。

4.5
编译是生成机器码？我还误以为是汇编呢。
不，它是汇编欸，汇编编译，当然是编译成机器码了。
