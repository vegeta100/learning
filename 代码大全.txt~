第7章 子程序
7.1
子程序使得一些代码抽象化，这样子，在查找问题的时候，才容易定位到问题的关键处。反过来，不用子程序，一眼看到的大量代码会令人不胜其烦。
多余的东西，多少有些干扰。可能会不自主地考虑代码细节，所以有些代码，应该抽象简化。

if else 嵌套了多层，看起来会很乱，那么，就需要你将某些内部的if else抽取出来，用子程序来替代。看起来才会比较有头绪。
当然，一般抽取成子程序，是需要传参的，参数如果过多，可以将相关的参数封装成实体类。

一些代码的执行先后是无关紧要的，那就隐藏起来。不必知道那些无关紧要的细节。

临时的内聚性：比如开始、结束阶段，需要同时初始化几样东西或销毁某几个对象。可以这么改善，将每一个初始化或销毁或其他操作抽取为一个子程序。
虽然不是十足的功能内聚性，但也比纯粹的临时内聚性要好。
startup那个例子，子程序命名为startup或是另一个提示巧合内聚的例子，都是可行的。

设计院的资源核查，可以用事件处理器。事件处理器使得看起来更加明了了，既然如此在文件内查找信息绝不该用滚动条，不然，还是要看到那大量的代码。
switch(int cmd){
	case pipe:
		searchPipe();
		break;
	case machineBox:
		searchMachineBox();
		break;
	case fiber:
		searchFiber();
		break;
}
有时候，这会成为逻辑性内聚，或称为非逻辑性内聚















第18章 表驱动法
if else
switch case都是逻辑语句

驱动：驱使它动，使设备工作起来
逻辑驱动：通过逻辑使程序工作起来
表驱动：通过表格使程序工作起来

表的形式：数组、链表	高级语言用数据库
还有枚举，但枚举我还没用过


子程序未必能减少代码量，但可以使代码更清晰。而表驱动，相对比逻辑驱动，是能够减少代码量的。表格不算代码的话。


灵活的消息格式：
打印存储在一份文件中的信息，文件中有500多条信息，20个类型。
浮标：水温、浮标位置

20个类型，共500多个浮标。这个理解似乎是错的，应该是一个浮标有20种信息，共500多条信息。也就是二三十个浮标。

浮标字段：
ID：标识浮标的消息类型

消息格式各不相同：
漂移信息：纬度改变、经度改变、测量时间
位置信息：纬度、经度、深度、测量时间

基于逻辑：
读取ID，判断消息类型

调用 “阅读信息、再打印信息” 的子程序。
针对不同的消息类型，就需要不同的子程序。
而如果是位置信息，其打印子程序可能需要纬度打印、经度打印和深度打印这三个子程序。

复杂度超乎想象，而面向对象的方法，由于子类间的消息并没有太多的共性，所以继承也只是使代码看起来没那么乱而已。

while循环，需要循环打印这份文件中的消息，循环500多次
每一条信息，都获取其消息头，即ID
用if else归属该调用哪个子程序

不管用子程序还是用面向对象，都精简不到哪去。打印纬度、打印经度、打印深度和其他的子程序是难以复用的。

表格还是可以通过struct实现的，字段长度一样就行。这并不算难。取最初的地址，然后不断递增。可能还有更好的办法。
一个泛型数组或许也是可以的，或者是枚举数组。但是表驱动我还理解得不够透彻，需要有个例子。java的或者android的。